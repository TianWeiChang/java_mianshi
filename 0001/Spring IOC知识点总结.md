Spring IOC知识点总结

## 广义的 IOC

在这之前，我们先记住一句话。好莱坞原则：**Don’t call me, we will call you.** 即“`不用打电话过来，我们会打给你`”。

控制反转（`Inversion of Control`，简称`IoC`），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（`Dependency Injection`，简称`DI`），还有一种方式叫“依赖查找”（`Dependency Lookup`）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。

两种实现： 依赖查找（DL）和依赖注入（DI）。

IOC 和 DI 、DL 的关系：

![image](E:\other\网络\assets\1305871056-eea26cda25619160_fix732.png)

- DI（`Dependency Injection`） 是 Spring 使用的方式，容器负责组件的装配。
- DL（`Dependency Lookup`）已经被抛弃。

## IOC容器的原理

IOC容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系。

- 原理就是通过Java的**反射技术**来实现的！通过反射我们可以获取类的所有信息(成员变量、类名等等等)！
- 再通过配置文件(xml)或者注解来**描述**类与类之间的关系
- 我们就可以通过这些配置信息和反射技术来**构建**出对应的对象和依赖关系了！

我们**简单**来看看实际Spring IOC容器是怎么实现对象的创建和依赖的：

![img](E:\other\网络\assets\3348921420-5b0410211112a_fix732.jpg)

1. 根据Bean配置信息在容器内部创建Bean定义注册表
2. 根据注册表加载、实例化bean、建立Bean与Bean之间的依赖关系
3. 将这些准备就绪的Bean放到Map缓存池中，等待应用程序调用

**Spring容器(Bean工厂)可简单分成两种**：

- BeanFactory
  - 这是最基础、面向Spring的
- ApplicationContext
  - ApplicationContext是BeanFactory的子类

> 没有特殊要求的情况下，应该使用ApplicationContext完成。因为BeanFactory能完成的事情，ApplicationContext都能完成，并且提供了更多接近现在开发的功能。

## 对IOC的理解

首先，IOC控制反转

**谁控制谁，控制什么，什么是反转（有反转就应该有正转了）**

**谁控制谁，控制什么**：

- 在之前，没有IOC时，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；
- 而现在，是由IOC专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；
- `谁控制谁？`当然是IOC容器控制了对象；`控制什么？`那就是主要控制了外部资源获取（不只是对象还包括比如文件等）。

**所谓反转**：

- 有反转就应该有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；
- 而所谓的反转，其实是反转的控制权，由 `Spring` 来控制对象的生命周期，那么对象的控制就完全脱离了我们的控制，控制权交给了`Spring `。这个反转是指：我们由对象的控制者变成了` IOC` 的被动控制者。

其次，说到`IOC`就会想到`DI 依赖注入`(IOC 是通过DI来实现的),那么：

**谁依赖谁，为什么需要依赖；谁注入谁，注入了什么**

- **谁依赖谁**：A对象 依赖于 IOC 容器。
- **为什么需要依赖**：A对象需要 IOC 容器提供对象需要的数据、B对象 等外部资源，没有这些资源不能完成业务处理。
- **谁注入谁**：IOC 容器注入 A对象。
- **注入了什么**：IOC 容器将 A对象 需要的数据、B对象等外部资源**按需**注入给对象。

**好处：** 降低了开发的成本，提高了代码复用率、软件的灵活性。

## 总结

IOC：不是什么技术，而是一种设计思想。在 `Spring` 开发中，由 `IOC` 容器控制对象的创建、初始化、销毁等。这也就实现了对象控制权的反转，由**我们对对象的控制**转变成了**Spring IOC 对对象的控制**。

DI：是 `IOC` 的具体实现。程序把依赖交给容器，容器帮你管理依赖。