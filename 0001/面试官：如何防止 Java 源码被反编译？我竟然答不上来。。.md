面试官：如何防止 Java 源码被反编译？我竟然答不上来。。

java作为解释型的语言，其高度抽象的特性意味其很容易被反编译，容易被反编译，自然有防止反编译措施存在。今天就拜读了一篇相关的文章，受益匪浅，知彼知己嘛！！

之所以会对java的反编译感兴趣，那是因为自己在学习的过程中，常常需要借鉴一下别人的成果（你懂的...）。或许反编译别人的代码不怎么道德，这个嘛......

**废话不多说，正文如下：**

常用的保护技术

由于Java字节码的抽象级别较高，因此它们较容易被反编译。本节介绍了几种常用的方法，用于保护Java字节码不被反编译。通常，这些方法不能够绝对防止程序被反编译，而是加大反编译的难度而已，因为这些方法都有自己的使用环境和弱点。

## 1. 隔离Java程序

最简单的方法就是让用户不能够访问到Java Class程序，这种方法是最根本的方法，具体实现有多种方式。例如，开发人员可以将关键的Java Class放在服务器端，客户端通过访问服务器的相关接口来获得服务，而不是直接访问Class文件。

这样黑客就没有办法反编译Class文件。

目前，通过接口提供服务的标准和协议也越来越多，例如 HTTP、Web Service、RPC等。但是有很多应用都不适合这种保护方式，例如对于单机运行的程序就无法隔离Java程序。这种保护方式见图1所示。

![图1隔离Java程序示意图](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS698sUKEqUmHwiaW4xZXfcR5HJ9ACfr8dAktLsmrMHfyn0FHl8osTByM1A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 2. 对Class文件进行加密

为了防止Class文件被直接反编译，许多开发人员将一些关键的Class文件进行加密，例如对注册码、序列号管理相关的类等。在使用这些被加密的类之前，程序首先需要对这些类进行解密，而后再将这些类装载到`JVM`当中。这些类的解密可以由硬件完成，也可以使用软件完成。

在实现时，开发人员往往通过自定义`ClassLoader`类来完成加密类的装载(注意由于安全性的原因，Applet不能够支持自定义的 `ClassLoader`)。自定义的`ClassLoader`首先找到加密的类，而后进行解密，最后将解密后的类装载到`JVM`当中。

在这种保护方式中，自定义的ClassLoader是非常关键的类。由于它本身不是被加密的，因此它可能成为黑客最先攻击的目标。如果相关的解密密钥和算法被攻克，那么被加密的类也很容易被解密。这种保护方式示意图见图2。

![图2 对Class文件进行加密示意图](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS69n6zx6AWHpE72V9anCoLyiaF4PJxQ3MtQ4UAcdbPibgketUF0roekAjvw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 3. 转换成本地代码

将程序转换成本地代码也是一种防止反编译的有效方法。因为本地代码往往难以被反编译。开发人员可以选择将整个应用程序转换成本地代码，也可以选择关键模块转换。如果仅仅转换关键部分模块，Java程序在使用这些模块时，需要使用JNI技术进行调用。

当然，在使用这种技术保护Java程序的同时，也牺牲了Java的跨平台特性。对于不同的平台，我们需要维护不同版本的本地代码，这将加重软件支持和维护的工作。不过对于一些关键的模块，有时这种方案往往是必要的。

为了保证这些本地代码不被修改和替代，通常需要对这些代码进行数字签名。在使用这些本地代码之前，往往需要对这些本地代码进行认证，确保这些代码没有被黑客更改。如果签名检查通过，则调用相关JNI方法。这种保护方式示意图见图3。

![图3 转换成本地代码示意图](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS698Z5iaV89cQkcccldibsfNTkHIUvcy8qTecyianrMTyEzwNYP0aJ21C6kw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 4、代码混淆

代码混淆是对Class文件进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能(语义)。但是混淆后的代码很难被反编译，即反编译后得出的代码是非常难懂、晦涩的，因此反编译人员很难得出程序的真正语义。

从理论上来说，黑客如果有足够的时间，被混淆的代码仍然可能被破解，甚至目前有些人正在研制反混淆的工具。但是从实际情况来看，由于混淆技术的多元化发展，混淆理论的成熟，经过混淆的Java代码还是能够很好地防止反编译。下面我们会详细介绍混淆技术，因为混淆是一种保护Java程序的重要技术。图4是代码混淆的示图。

![图4 代码混淆示意图](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS69MQ0ShdlVTmmfGsDz4NsiaPzoEy4nT29keVpU0QURzAibkd2sEVFhIIVA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 总结

以上几种技术都有不同的应用环境，各自都有自己的弱点，表1是相关特点的比较。

![表1 不同保护技术比较表](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS6976Ph3qy9E1Jiaf1HW7uRT08oAnNH7UtpYyIpGfziaLtyZZOiaHPSFeMIw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

到目前为止，对于Java程序的保护，混淆技术还是最基本的保护方法。Java混淆工具也非常多，包括商业的、免费的、开放源代码的。Sun公司也提供了自己的混淆工具。它们大多都是对Class文件进行混淆处理，也有少量工具首先对源代码进行处理，然后再对Class进行处理，这样加大了混淆处理的力度。

目前，商业上比较成功的混淆工具包括JProof公司的1stBarrier系列、Eastridge公司的JShrink和 4thpass.com的SourceGuard等。主要的混淆技术按照混淆目标可以进行如下分类，它们分别为符号混淆(Lexical Obfuscation)、数据混淆(Data Obfuscation)、控制混淆(Control Obfuscation)、预防性混淆(Prevent Transformation)。

#### **符号混淆**

在Class中存在许多与程序执行本身无关的信息，例如方法名称、变量名称，这些符号的名称往往带有一定的含义。例如某个方法名为 getKeyLength()，那么这个方法很可能就是用来返回Key的长度。符号混淆就是将这些信息打乱，把这些信息变成无任何意义的表示，例如将所有的变量从vairant_001开始编号；对于所有的方法从method_001开始编号。这将对反编译带来一定的困难。

对于私有函数、局部变量，通常可以改变它们的符号，而不影响程序的运行。但是对于一些接口名称、公有函数、成员变量，如果有其它外部模块需要引用这些符号，我们往往需要保留这些名称，否则外部模块找不到这些名称的方法和变量。因此，多数的混淆工具对于符号混淆，都提供了丰富的选项，让用户选择是否、如何进行符号混淆。

#### **数据混淆**

![图5 改变数据访问](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS69liaibt9HI7O7OuUHoicDqicvPLHpzx0OEsia1mTNrMia3TqGVoq8jQalQQGw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

数据混淆是对程序使用的数据进行混淆。混淆的方法也有多种，主要可以分为改变数据存储及编码(Store and Encode Transform)、改变数据访问(Access Transform)。

改变数据存储和编码可以打乱程序使用的数据存储方式。例如将一个有10个成员的数组，拆开为10个变量，并且打乱这些变量的名字；将一个两维数组转化为一个一维数组等。对于一些复杂的数据结构，我们将打乱它的数据结构，例如用多个类代替一个复杂的类等。

另外一种方式是改变数据访问。例如访问数组的下标时，我们可以进行一定的计算，图5就是一个例子。

在实践混淆处理中，这两种方法通常是综合使用的，在打乱数据存储的同时，也打乱数据访问的方式。经过对数据混淆，程序的语义变得复杂了，这样增大了反编译的难度。

#### **控制混淆**

控制混淆就是对程序的控制流进行混淆，使得程序的控制流更加难以反编译，通常控制流的改变需要增加一些额外的计算和控制流，因此在性能上会给程序带来一定的负面影响。有时，需要在程序的性能和混淆程度之间进行权衡。控制混淆的技术最为复杂，技巧也最多。这些技术可以分为如下几类：

增加混淆控制通过增加额外的、复杂的控制流，可以将程序原来的语义隐藏起来。例如，对于按次序执行的两个语句A、B，我们可以增加一个控制条件，以决定B的执行。通过这种方式加大反汇编的难度。但是所有的干扰控制都不应该影响B的执行。图6就给出三种方式，为这个例子增加混淆控制。

![图6 增加混淆控制的三](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS69DpMjXG3icT8kHoicYM3aEcKPfWMy4NxkAAsnnWpEV53tLP886K4eyZrw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)种方式

控制流重组重组控制流也是重要的混淆方法。例如，程序调用一个方法，在混淆后，可以将该方法代码嵌入到调用程序当中。反过来，程序中的一段代码也可以转变为一个函数调用。

另外，对于一个循环的控制流，为可以拆分多个循环的控制流，或者将循环转化成一个递归过程。这种方法最为复杂，研究的人员也非常多。

#### **预防性混淆** 

这种混淆通常是针对一些专用的反编译器而设计的，一般来说，这些技术利用反编译器的弱点或者Bug来设计混淆方案。

例如，有些反编译器对于 Return后面的指令不进行反编译，而有些混淆方案恰恰将代码放在Return语句后面。这种混淆的有效性对于不同反编译器的作用也不太相同的。一个好的混淆工具，通常会综合使用这些混淆技术。

#### **案例分析**

在实践当中，保护一个大型Java程序经常需要综合使用这些方法，而不是单一使用某一种方法。这是因为每种方法都有其弱点和应用环境。综合使用这些方法使得Java程序的保护更加有效。另外，我们经常还需要使用其它的相关安全技术，例如安全认证、数字签名、PKI等。

本文给出的例子是一个Java应用程序，它是一个SCJP(Sun Certificate Java Programmer)的模拟考试软件。该应用程序带有大量的模拟题目，所有的题目都被加密后存储在文件中。由于它所带的题库是该软件的核心部分，所以关于题库的存取和访问就成为非常核心的类。一旦这些相关的类被反编译，则所有的题库将被破解。现在，我们来考虑如何保护这些题库及相关的类。

在这个例子中，我们考虑使用综合保护技术，其中包括本地代码和混淆技术。因为该软件主要发布在Windows上，因此转换成本地代码后，仅仅需要维护一个版本的本地代码。另外，混淆对Java程序也是非常有效的，适用于这种独立发布的应用系统。

在具体的方案中，我们将程序分为两个部分，一个是由本地代码编写的题库访问的模块，另外一个是由Java开发的其它模块。这样可以更高程度地保护题目管理模块不被反编译。对于Java开发的模块，我们仍然要使用混淆技术。该方案的示意图参见图7。

![图7 SCJP保护技术方案图](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS69Gt6DcJo2T5nP52dtAshNTBxLaG0PHL0LpjlHxBK3ASD5s6ecuDa2ZQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

对于题目管理模块，由于程序主要在Windows下使用，所以使用C++开发题库访问模块，并且提供了一定的访问接口。为了保护题库访问的接口，我们还增加了一个初始化接口，用于每次使用题库访问接口之前的初始化工作。它的接口主要分为两类：

**1． 初始化接口**

在使用题库模块之前，我们必须先调用初始化接口。在调用该接口时，客户端需要提供一个随机数作为参数。题库管理模块和客户端通过这个随机数，按一定的算法同时生成相同的SessionKey，用于加密以后输入和输出的所有数据。

通过这种方式，只有授权(有效)的客户端才能够连接正确的连接，生成正确的 SessionKey，用于访问题库信息。非法的客户很难生成正确的SessionKey，因此无法获得题库的信息。如果需要建立更高的保密级别，也可以采用双向认证技术。

**2． 数据访问接口**

认证完成之后，客户端就可以正常的访问题库数据。但是，输入和输出的数据都是由SessionKey所加密的数据。因此，只有正确的题库管理模块才能够使用题库管理模块。图8时序图表示了题库管理模块和其它部分的交互过程。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/VrAGWevWkSRgLhxgfiand1icb6IY3sKS69Fd1h00XVQE26pbIYQ5nJWI9JfPa16TrGR1NLLaWJNlm9r3wHWo66hw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

dsadasdsa